<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>LIBWIRE: libwire::udp::socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LIBWIRE
   </div>
   <div id="projectbrief">Next-generation C++17 networking library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibwire.html">libwire</a></li><li class="navelem"><a class="el" href="namespacelibwire_1_1udp.html">udp</a></li><li class="navelem"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlibwire_1_1udp_1_1socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libwire::udp::socket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Descriptor wrapper for UDP socket.  
 <a href="classlibwire_1_1udp_1_1socket.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a530f3dffdcc6207c127eeb8c132d840f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a530f3dffdcc6207c127eeb8c132d840f">socket</a> (<a class="el" href="namespacelibwire.html#aaac2ed5914ee7680ce2a560d4e38f4da">ip</a> ipver) noexcept</td></tr>
<tr class="memdesc:a530f3dffdcc6207c127eeb8c132d840f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new socket object.  <a href="#a530f3dffdcc6207c127eeb8c132d840f">More...</a><br/></td></tr>
<tr class="separator:a530f3dffdcc6207c127eeb8c132d840f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a649cbda3b0cdd2415a220394db40a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a2a649cbda3b0cdd2415a220394db40a9">socket</a> (const <a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;)=delete</td></tr>
<tr class="separator:a2a649cbda3b0cdd2415a220394db40a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55cc2d96c825b84bd0b89d24c3282e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#ae55cc2d96c825b84bd0b89d24c3282e4">socket</a> (<a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ae55cc2d96c825b84bd0b89d24c3282e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23045bf20a8a6db915eb7356572fc95c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a23045bf20a8a6db915eb7356572fc95c">~socket</a> ()</td></tr>
<tr class="memdesc:a23045bf20a8a6db915eb7356572fc95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate socket.  <a href="#a23045bf20a8a6db915eb7356572fc95c">More...</a><br/></td></tr>
<tr class="separator:a23045bf20a8a6db915eb7356572fc95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ba9de4dc8afe819639895d54cb10e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a82ba9de4dc8afe819639895d54cb10e7">associate</a> (<a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> target, std::error_code &amp;ec) noexcept</td></tr>
<tr class="memdesc:a82ba9de4dc8afe819639895d54cb10e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate UDP socket with remote endpoint.  <a href="#a82ba9de4dc8afe819639895d54cb10e7">More...</a><br/></td></tr>
<tr class="separator:a82ba9de4dc8afe819639895d54cb10e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918ff6bfb7f4255beee808b709d1cb08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a918ff6bfb7f4255beee808b709d1cb08">close</a> () noexcept</td></tr>
<tr class="memdesc:a918ff6bfb7f4255beee808b709d1cb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate socket.  <a href="#a918ff6bfb7f4255beee808b709d1cb08">More...</a><br/></td></tr>
<tr class="separator:a918ff6bfb7f4255beee808b709d1cb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af452499c121c508677c97e5664e344df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#af452499c121c508677c97e5664e344df">disassociate</a> () noexcept</td></tr>
<tr class="memdesc:af452499c121c508677c97e5664e344df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo previous call to associate().  <a href="#af452499c121c508677c97e5664e344df">More...</a><br/></td></tr>
<tr class="separator:af452499c121c508677c97e5664e344df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dd329f7aac7d806287341a3b576813"><td class="memItemLeft" align="right" valign="top">internal_::socket &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a86dd329f7aac7d806287341a3b576813">implementation</a> () noexcept</td></tr>
<tr class="separator:a86dd329f7aac7d806287341a3b576813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9705f28e0b7a3e21730008c196eb7482"><td class="memItemLeft" align="right" valign="top">const internal_::socket &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a9705f28e0b7a3e21730008c196eb7482">implementation</a> () const noexcept</td></tr>
<tr class="separator:a9705f28e0b7a3e21730008c196eb7482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87efdf04d3ef17e51d583317fe254581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a87efdf04d3ef17e51d583317fe254581">listen</a> (<a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> target, std::error_code &amp;ec) noexcept</td></tr>
<tr class="memdesc:a87efdf04d3ef17e51d583317fe254581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept datagrams coming on specified endpoint.  <a href="#a87efdf04d3ef17e51d583317fe254581">More...</a><br/></td></tr>
<tr class="separator:a87efdf04d3ef17e51d583317fe254581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20cd2002a968f2c7bb33640e3307352"><td class="memItemLeft" align="right" valign="top">internal_::socket::native_handle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#aa20cd2002a968f2c7bb33640e3307352">native_handle</a> () const noexcept</td></tr>
<tr class="memdesc:aa20cd2002a968f2c7bb33640e3307352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get native handle/descriptor for socket.  <a href="#aa20cd2002a968f2c7bb33640e3307352">More...</a><br/></td></tr>
<tr class="separator:aa20cd2002a968f2c7bb33640e3307352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc21fb1c84acdcf5329bd2008aca1787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#adc21fb1c84acdcf5329bd2008aca1787">operator=</a> (const <a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;)=delete</td></tr>
<tr class="separator:adc21fb1c84acdcf5329bd2008aca1787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84211e9dc5f8d89f2f4b7c560016f39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#a84211e9dc5f8d89f2f4b7c560016f39a">operator=</a> (<a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a84211e9dc5f8d89f2f4b7c560016f39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Socket options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Several aspects of socket behavior can be changes by setting flags.</p>
<p>See <a class="el" href="classlibwire_1_1tcp_1_1socket.html">tcp::socket</a> documentation for detailed explanation of socket options mechanism. There are no special options for UDP sockets. </p>
</div></td></tr>
<tr class="memitem:ae2f281a8a5debd56dcf6f2cea688adc4"><td class="memTemplParams" colspan="2">template&lt;typename Option &gt; </td></tr>
<tr class="memitem:ae2f281a8a5debd56dcf6f2cea688adc4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#ae2f281a8a5debd56dcf6f2cea688adc4">option</a> (const Option &amp;) const noexcept</td></tr>
<tr class="memdesc:ae2f281a8a5debd56dcf6f2cea688adc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query socket option value specified by type tag Option.  <a href="#ae2f281a8a5debd56dcf6f2cea688adc4">More...</a><br/></td></tr>
<tr class="separator:ae2f281a8a5debd56dcf6f2cea688adc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2847df5092646e9d4154c6758bd629"><td class="memTemplParams" colspan="2">template&lt;typename Option , typename... Args&gt; </td></tr>
<tr class="memitem:ace2847df5092646e9d4154c6758bd629"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#ace2847df5092646e9d4154c6758bd629">set_option</a> (const Option &amp;, Args &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:ace2847df5092646e9d4154c6758bd629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket option value specified by type tag Option to value value.  <a href="#ace2847df5092646e9d4154c6758bd629">More...</a><br/></td></tr>
<tr class="separator:ace2847df5092646e9d4154c6758bd629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Blocking I/O</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>I/O functions in this category usually block thread until operation is completed. </p>
</div></td></tr>
<tr class="memitem:ad53276961f2c70e1d0dfad8b0c9cd5b1"><td class="memTemplParams" colspan="2">template&lt;typename Buffer  = std::vector&lt;uint8_t&gt;&gt; </td></tr>
<tr class="memitem:ad53276961f2c70e1d0dfad8b0c9cd5b1"><td class="memTemplItemLeft" align="right" valign="top">Buffer &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#ad53276961f2c70e1d0dfad8b0c9cd5b1">read</a> (size_t bytes_count, Buffer &amp;, std::error_code &amp;, <a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> *source=nullptr) noexcept</td></tr>
<tr class="memdesc:ad53276961f2c70e1d0dfad8b0c9cd5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pending datagram into buffer.  <a href="#ad53276961f2c70e1d0dfad8b0c9cd5b1">More...</a><br/></td></tr>
<tr class="separator:ad53276961f2c70e1d0dfad8b0c9cd5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c70c4f0f36184fa4bbbc09092a0f4b"><td class="memTemplParams" colspan="2">template&lt;typename Buffer  = std::vector&lt;uint8_t&gt;&gt; </td></tr>
<tr class="memitem:aa6c70c4f0f36184fa4bbbc09092a0f4b"><td class="memTemplItemLeft" align="right" valign="top">Buffer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#aa6c70c4f0f36184fa4bbbc09092a0f4b">read</a> (size_t bytes_count, std::error_code &amp;, <a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> *source=nullptr) noexcept</td></tr>
<tr class="memdesc:aa6c70c4f0f36184fa4bbbc09092a0f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as overload with Buffer argument but return newly allocated buffer every time.  <a href="#aa6c70c4f0f36184fa4bbbc09092a0f4b">More...</a><br/></td></tr>
<tr class="separator:aa6c70c4f0f36184fa4bbbc09092a0f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6b647c6da463615ee56522d2f14223"><td class="memTemplParams" colspan="2">template&lt;typename Buffer  = std::vector&lt;uint8_t&gt;&gt; </td></tr>
<tr class="memitem:aaa6b647c6da463615ee56522d2f14223"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibwire_1_1udp_1_1socket.html#aaa6b647c6da463615ee56522d2f14223">write</a> (const Buffer &amp;, std::error_code &amp;, const <a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> &amp;dest=<a class="el" href="structlibwire_1_1endpoint.html#aedc163c28fd1f3e56f511b2ceb8e9bc9">endpoint::invalid</a>) noexcept</td></tr>
<tr class="memdesc:aaa6b647c6da463615ee56522d2f14223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write contents of buffer to socket.  <a href="#aaa6b647c6da463615ee56522d2f14223">More...</a><br/></td></tr>
<tr class="separator:aaa6b647c6da463615ee56522d2f14223"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Descriptor wrapper for UDP socket. </p>
<p>UDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability of TCP isn't important.</p>
<h5>Thread-safety</h5>
<ul>
<li>Distinct: safe</li>
<li>Same: unsafe </li>
</ul>

<p>Definition at line <a class="el" href="udp_2socket_8hpp_source.html#l00056">56</a> of file <a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a530f3dffdcc6207c127eeb8c132d840f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libwire::udp::socket::socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibwire.html#aaac2ed5914ee7680ce2a560d4e38f4da">ip</a>&#160;</td>
          <td class="paramname"><em>ipver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new socket object. </p>
<p>If socket allocationf ailed we will set socket to closed state.</p>
<dl class="section note"><dt>Note</dt><dd>As opposed to TCP you should specify IP protocol version here because we can't guess it from future connect() or bind() call because there may be none. And we should not (re-)allocate socket in I/O operations to prevent strange performance problems when you are jumping between IPv6 and IPv4 too often. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a649cbda3b0cdd2415a220394db40a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libwire::udp::socket::socket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae55cc2d96c825b84bd0b89d24c3282e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libwire::udp::socket::socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a23045bf20a8a6db915eb7356572fc95c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libwire::udp::socket::~socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate socket. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a82ba9de4dc8afe819639895d54cb10e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libwire::udp::socket::associate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibwire_1_1endpoint.html">endpoint</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate UDP socket with remote endpoint. </p>
<p>This will allow you to omit target endpoint from further calls to write(). Also, socket will not receive datagrams sent from endpoints other than specified.</p>
<p>ec will be set to <a class="el" href="namespacelibwire_1_1error.html#a67e895a0422455076608443966da641aa30d20b3b42ec91cbaa2628d0794c4e05">error::invalid_argument</a> if passed address object have IP version different from one passed to socket constructor. </p>

</div>
</div>
<a class="anchor" id="a918ff6bfb7f4255beee808b709d1cb08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libwire::udp::socket::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate socket. </p>
<p>This makes this instance unusable. </p>

</div>
</div>
<a class="anchor" id="af452499c121c508677c97e5664e344df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libwire::udp::socket::disassociate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Undo previous call to associate(). </p>
<p>Have no effect if associate() is not used. </p>

</div>
</div>
<a class="anchor" id="a86dd329f7aac7d806287341a3b576813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal_::socket&amp; libwire::udp::socket::implementation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9705f28e0b7a3e21730008c196eb7482"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const internal_::socket&amp; libwire::udp::socket::implementation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87efdf04d3ef17e51d583317fe254581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libwire::udp::socket::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibwire_1_1endpoint.html">endpoint</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accept datagrams coming on specified endpoint. </p>
<p>ec will be set if something went wrong. </p>

</div>
</div>
<a class="anchor" id="aa20cd2002a968f2c7bb33640e3307352"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal_::socket::native_handle_t libwire::udp::socket::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get native handle/descriptor for socket. </p>
<p>Returned value is undefined if is_open returns false. </p>

</div>
</div>
<a class="anchor" id="adc21fb1c84acdcf5329bd2008aca1787"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a>&amp; libwire::udp::socket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84211e9dc5f8d89f2f4b7c560016f39a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a>&amp; libwire::udp::socket::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibwire_1_1udp_1_1socket.html">socket</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2f281a8a5debd56dcf6f2cea688adc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Option &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto libwire::udp::socket::option </td>
          <td>(</td>
          <td class="paramtype">const Option &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query socket option value specified by type tag Option. </p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="classlibwire_1_1udp_1_1socket.html#a530f3dffdcc6207c127eeb8c132d840f">socket</a>.option(<a class="code" href="namespacelibwire_1_1tcp_1_1options.html#adcb1e174ec2434fdabd944ceb377ca86">tcp::no_delay</a>); <span class="comment">// =&gt; false by default.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Some options May have multiple values returned in tuple.</span></div>
<div class="line"><span class="keyword">auto</span> [ enabled, <a class="code" href="namespacelibwire_1_1error.html#a67e895a0422455076608443966da641aaf978e687739b83719491d14637bba2a2">timeout</a> ] = <a class="code" href="classlibwire_1_1udp_1_1socket.html#a530f3dffdcc6207c127eeb8c132d840f">socket</a>.option(<a class="code" href="namespacelibwire_1_1tcp_1_1options.html#a3b1af4895d05e0c59cb92673bcaceea1">tcp::linger</a>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="udp_2socket_8hpp_source.html#l00119">119</a> of file <a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad53276961f2c70e1d0dfad8b0c9cd5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Buffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Buffer &amp; libwire::udp::socket::read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> *&#160;</td>
          <td class="paramname"><em>source</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read pending datagram into buffer. </p>
<p>If buffer is not large enough to fit entire datagram it will be truncated. If buffer is smaller than datagram it will be resized to datagram size.</p>
<p>If src contains non-null pointer, datagram source endpoint will be written to it.</p>
<p><b>Buffer type requirements:</b></p>
<p>Buffer must be container that encapsulates dynamic array, so it must have data, size and resize member functions with behavior as in std::vector. </p>

<p>Definition at line <a class="el" href="udp_2socket_8hpp_source.html#l00256">256</a> of file <a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6c70c4f0f36184fa4bbbc09092a0f4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Buffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Buffer libwire::udp::socket::read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> *&#160;</td>
          <td class="paramname"><em>source</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as overload with Buffer argument but return newly allocated buffer every time. </p>

<p>Definition at line <a class="el" href="udp_2socket_8hpp_source.html#l00274">274</a> of file <a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace2847df5092646e9d4154c6758bd629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Option , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libwire::udp::socket::set_option </td>
          <td>(</td>
          <td class="paramtype">const Option &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set socket option value specified by type tag Option to value value. </p>
<p>Setting option not supported on current platform or specifying invalid value results in undefined behavior. But usually new value just ignored and corresponding option(tag) will return old value.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="classlibwire_1_1udp_1_1socket.html#a530f3dffdcc6207c127eeb8c132d840f">socket</a>.set_option(<a class="code" href="namespacelibwire_1_1tcp_1_1options.html#adcb1e174ec2434fdabd944ceb377ca86">tcp::no_delay</a>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Some options may have multiple values:</span></div>
<div class="line"><a class="code" href="classlibwire_1_1udp_1_1socket.html#a530f3dffdcc6207c127eeb8c132d840f">socket</a>.set_option(<a class="code" href="namespacelibwire_1_1tcp_1_1options.html#a3b1af4895d05e0c59cb92673bcaceea1">tcp::linger</a>, <span class="keyword">true</span>, 20s);</div>
<div class="line"><span class="comment">// ^ enable linger with 20 seconds timeout.</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="udp_2socket_8hpp_source.html#l00141">141</a> of file <a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa6b647c6da463615ee56522d2f14223"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Buffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libwire::udp::socket::write </td>
          <td>(</td>
          <td class="paramtype">const Buffer &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlibwire_1_1endpoint.html">endpoint</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em> = <code><a class="el" href="structlibwire_1_1endpoint.html#aedc163c28fd1f3e56f511b2ceb8e9bc9">endpoint::invalid</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write contents of buffer to socket. </p>
<p>Error code will be set if anything went wrong.</p>
<p>dest argument will override destination specified using <a class="el" href="classlibwire_1_1udp_1_1socket.html#a82ba9de4dc8afe819639895d54cb10e7">associate</a>.</p>
<p><b>Buffer type requirements</b></p>
<p>Buffer must be container that encapsulates dynamic array, so it must have data and size member functions with behavior as in std::vector. </p>

<p>Definition at line <a class="el" href="udp_2socket_8hpp_source.html#l00287">287</a> of file <a class="el" href="udp_2socket_8hpp_source.html">socket.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 15 2018 20:41:05 for LIBWIRE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
